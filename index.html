<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris</title>
  <style>
    :root {
      --bg-1: #f6f5ef;
      --bg-2: #e0dfd5;
      --panel: #1f2421;
      --panel-2: #2f3a35;
      --text: #f4f7f5;
      --muted: #c3ccc8;
      --accent: #d96f32;
      --grid: #0f1110;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", "Noto Sans KR", sans-serif;
      background: radial-gradient(circle at 20% 20%, var(--bg-1), var(--bg-2));
      display: grid;
      place-items: center;
      padding: 20px;
    }

    .wrap {
      width: min(960px, 100%);
      display: grid;
      grid-template-columns: minmax(280px, 380px) minmax(220px, 1fr);
      gap: 20px;
      align-items: start;
    }

    .board-panel,
    .side-panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border-radius: 16px;
      padding: 16px;
      color: var(--text);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.22);
    }

    h1 {
      margin: 0 0 12px;
      font-size: 1.6rem;
      letter-spacing: 0.03em;
    }

    canvas {
      width: 100%;
      max-width: 360px;
      background: var(--grid);
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.08);
      image-rendering: pixelated;
    }

    .meta {
      display: grid;
      gap: 10px;
      margin-top: 14px;
    }

    .item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 0.95rem;
    }

    .item strong { color: var(--accent); }

    .keys {
      margin-top: 14px;
      display: grid;
      gap: 8px;
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    button {
      margin-top: 14px;
      border: 0;
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      padding: 10px 14px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
    }

    .next-box {
      width: 120px;
      height: 120px;
      background: #0f1110;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      margin-top: 6px;
    }

    #next {
      width: 96px;
      height: 96px;
      image-rendering: pixelated;
    }

    @media (max-width: 760px) {
      .wrap { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="board-panel">
      <h1>테트리스</h1>
      <canvas id="board" width="300" height="600"></canvas>
      <div class="meta">
        <div class="item"><span>점수</span><strong id="score">0</strong></div>
        <div class="item"><span>레벨</span><strong id="level">1</strong></div>
        <div class="item"><span>라인</span><strong id="lines">0</strong></div>
      </div>
      <button id="restart">다시 시작</button>
    </section>

    <aside class="side-panel">
      <div>다음 블록</div>
      <div class="next-box"><canvas id="next" width="96" height="96"></canvas></div>
      <div class="keys">
        <div>← / → : 이동</div>
        <div>↑ : 회전</div>
        <div>↓ : 소프트 드롭</div>
        <div>Space : 하드 드롭</div>
        <div>P : 일시정지</div>
      </div>
    </aside>
  </main>

  <script>
    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 30;
    const LINES_PER_LEVEL = 10;

    const COLORS = {
      I: '#44c7f4',
      O: '#f5d547',
      T: '#b66af2',
      S: '#5ac96f',
      Z: '#f05d66',
      J: '#4f79ea',
      L: '#f29d4b'
    };

    const SHAPES = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]]
    };

    const boardCanvas = document.getElementById('board');
    const boardCtx = boardCanvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const linesEl = document.getElementById('lines');
    const restartBtn = document.getElementById('restart');

    let board;
    let current;
    let next;
    let score;
    let lines;
    let level;
    let gameOver;
    let paused;
    let lastTime = 0;
    let dropCounter = 0;

    function createBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function randomType() {
      const keys = Object.keys(SHAPES);
      return keys[(Math.random() * keys.length) | 0];
    }

    function createPiece(type = randomType()) {
      const shape = SHAPES[type].map(row => [...row]);
      return {
        type,
        shape,
        x: ((COLS - shape[0].length) / 2) | 0,
        y: 0
      };
    }

    function rotate(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
    }

    function collide(b, p) {
      return p.shape.some((row, y) =>
        row.some((v, x) => v && (
          b[p.y + y] === undefined ||
          b[p.y + y][p.x + x] === undefined ||
          b[p.y + y][p.x + x]
        ))
      );
    }

    function merge(b, p) {
      p.shape.forEach((row, y) => {
        row.forEach((v, x) => {
          if (v) b[p.y + y][p.x + x] = p.type;
        });
      });
    }

    function clearLines() {
      let cleared = 0;

      outer:
      for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          if (!board[y][x]) continue outer;
        }
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        cleared++;
        y++;
      }

      if (cleared > 0) {
        const scores = [0, 100, 300, 500, 800];
        score += scores[cleared] * level;
        lines += cleared;
        level = (lines / LINES_PER_LEVEL | 0) + 1;
        updateUI();
      }
    }

    function spawn() {
      current = next || createPiece();
      next = createPiece();
      current.x = ((COLS - current.shape[0].length) / 2) | 0;
      current.y = 0;

      if (collide(board, current)) {
        gameOver = true;
      }
      drawNext();
    }

    function move(dir) {
      current.x += dir;
      if (collide(board, current)) current.x -= dir;
    }

    function softDrop() {
      current.y++;
      if (collide(board, current)) {
        current.y--;
        lockPiece();
      }
      dropCounter = 0;
    }

    function hardDrop() {
      while (!collide(board, current)) current.y++;
      current.y--;
      lockPiece();
      dropCounter = 0;
    }

    function rotateCurrent() {
      const prev = current.shape;
      const rotated = rotate(current.shape);
      current.shape = rotated;

      const shifts = [0, -1, 1, -2, 2];
      for (const s of shifts) {
        current.x += s;
        if (!collide(board, current)) return;
        current.x -= s;
      }

      current.shape = prev;
    }

    function lockPiece() {
      merge(board, current);
      clearLines();
      spawn();
    }

    function dropInterval() {
      return Math.max(100, 900 - (level - 1) * 80);
    }

    function drawCell(ctx, x, y, color, size) {
      ctx.fillStyle = color;
      ctx.fillRect(x * size, y * size, size, size);
      ctx.fillStyle = 'rgba(255,255,255,.2)';
      ctx.fillRect(x * size, y * size, size, 3);
      ctx.fillStyle = 'rgba(0,0,0,.18)';
      ctx.fillRect(x * size, y * size + size - 3, size, 3);
      ctx.strokeStyle = 'rgba(0,0,0,.25)';
      ctx.strokeRect(x * size + .5, y * size + .5, size - 1, size - 1);
    }

    function drawBoard() {
      boardCtx.fillStyle = '#0f1110';
      boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);

      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const v = board[y][x];
          if (v) drawCell(boardCtx, x, y, COLORS[v], BLOCK);
        }
      }

      if (!gameOver) {
        current.shape.forEach((row, y) => {
          row.forEach((v, x) => {
            if (v) drawCell(boardCtx, current.x + x, current.y + y, COLORS[current.type], BLOCK);
          });
        });
      }

      if (paused || gameOver) {
        boardCtx.fillStyle = 'rgba(0,0,0,.55)';
        boardCtx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
        boardCtx.fillStyle = '#fff';
        boardCtx.font = 'bold 28px Segoe UI';
        boardCtx.textAlign = 'center';
        boardCtx.fillText(gameOver ? 'GAME OVER' : 'PAUSED', boardCanvas.width / 2, boardCanvas.height / 2);
      }
    }

    function drawNext() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      const shape = next.shape;
      const cell = 24;
      const ox = ((nextCanvas.width - shape[0].length * cell) / 2) | 0;
      const oy = ((nextCanvas.height - shape.length * cell) / 2) | 0;

      shape.forEach((row, y) => {
        row.forEach((v, x) => {
          if (v) {
            nextCtx.fillStyle = COLORS[next.type];
            nextCtx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
            nextCtx.strokeStyle = 'rgba(0,0,0,.25)';
            nextCtx.strokeRect(ox + x * cell + .5, oy + y * cell + .5, cell - 1, cell - 1);
          }
        });
      });
    }

    function updateUI() {
      scoreEl.textContent = score;
      levelEl.textContent = level;
      linesEl.textContent = lines;
    }

    function resetGame() {
      board = createBoard();
      score = 0;
      lines = 0;
      level = 1;
      gameOver = false;
      paused = false;
      dropCounter = 0;
      next = createPiece();
      spawn();
      updateUI();
    }

    function update(time = 0) {
      const delta = time - lastTime;
      lastTime = time;

      if (!paused && !gameOver) {
        dropCounter += delta;
        if (dropCounter > dropInterval()) softDrop();
      }

      drawBoard();
      requestAnimationFrame(update);
    }

    document.addEventListener('keydown', e => {
      if (e.code === 'KeyP') {
        paused = !paused;
        return;
      }

      if (paused || gameOver) return;

      if (e.code === 'ArrowLeft') move(-1);
      else if (e.code === 'ArrowRight') move(1);
      else if (e.code === 'ArrowUp') rotateCurrent();
      else if (e.code === 'ArrowDown') softDrop();
      else if (e.code === 'Space') {
        e.preventDefault();
        hardDrop();
      }
    });

    restartBtn.addEventListener('click', resetGame);

    resetGame();
    update();
  </script>
</body>
</html>
